// This is a generated file by witgen (https://github.com/bnjjj/witgen), please do not edit yourself, you can generate a new one thanks to cargo witgen generate command. (witme v0.1.0) 

// This is a generated file by witgen (https://github.com/bnjjj/witgen), please do not edit yourself, you can generate a new one thanks to cargo witgen generate command. (cargo-witgen v0.0.2) 

record storage-balance-bounds {
    min: u128,
	max: option<u128>
}

record fungible-token-metadata {
    spec: string,
	name: string,
	symbol: string,
	icon: option<string>,
	reference: option<string>,
	reference-hash: option<base64-vec-u8>,
	decimals: u8
}

///  In this implementation, the Token struct takes two extensions standards (metadata and approval) as optional fields, as they are frequently used in modern NFTs.
record token {
    token-id: token-id,
	owner-id: account-id,
	metadata: option<token-metadata>,
	approved-account-ids: option<list<tuple<account-id,u64>>>
}

///  Note that token IDs for NFTs are strings on NEAR. It's still fine to use autoincrementing numbers as unique IDs if desired, but they should be stringified. This is to make IDs more future-proof as chain-agnostic conventions and standards arise, and allows for more flexibility with considerations like bridging NFTs across chains, etc.
type token-id = string

record storage-balance {
    total: u128,
	available: u128
}

type wrapped-duration = string

///  Metadata on the individual token level.
record token-metadata {
    title: option<string>,
	description: option<string>,
	media: option<string>,
	media-hash: option<base64-vec-u8>,
	copies: option<u64>,
	issued-at: option<string>,
	expires-at: option<string>,
	starts-at: option<string>,
	updated-at: option<string>,
	extra: option<string>,
	reference: option<string>,
	reference-hash: option<base64-vec-u8>
}

///  Metadata for the NFT contract itself.
record nft-contract-metadata {
    spec: string,
	name: string,
	symbol: string,
	icon: option<string>,
	base-uri: option<string>,
	reference: option<string>,
	reference-hash: option<base64-vec-u8>
}



// This is a generated file by witgen (https://github.com/bnjjj/witgen), please do not edit yourself, you can generate a new one thanks to cargo witgen generate command. (cargo-witgen v0.0.2) 

///  StorageUsage is used to count the amount of storage used by a contract.
type storage-usage = u64

///  Balance is a type for storing amounts of tokens, specified in yoctoNEAR.
type balance = u128

///  Represents the amount of NEAR tokens in "gas units" which are used to fund transactions.
type gas = u64

///  base64 string.
type base64-vec-u8 = string

///  Raw type for duration in nanoseconds
type duration = u64

type u128 = string

///  Public key in a binary format with base58 string serialization with human-readable curve.
///  The key types currently supported are `secp256k1` and `ed25519`.
/// 
///  Ed25519 public keys accepted are 32 bytes and secp256k1 keys are the uncompressed 64 format.
type public-key = string

type account-id = string

///  Raw type for timestamp in nanoseconds
type timestamp = u64

nft-total-supply: function() -> u128


nft-tokens: function(from-index: option<u128>, limit: option<u64>) -> list<token>


///  change
nft-approve: function(token-id: token-id, account-id: account-id, msg: option<string>)

///  Simple transfer. Transfer a given `token_id` from current owner to
///  `receiver_id`.
/// 
///  Requirements
///  * Caller of the method must attach a deposit of 1 yoctoⓃ for security purposes
///  * Contract MUST panic if called by someone other than token owner or,
///    if using Approval Management, one of the approved accounts
///  * `approval_id` is for use with Approval Management,
///    see <https://nomicon.io/Standards/NonFungibleToken/ApprovalManagement.html>
///  * If using Approval Management, contract MUST nullify approved accounts on
///    successful transfer.
///  * TODO: needed? Both accounts must be registered with the contract for transfer to
///    succeed. See see <https://nomicon.io/Standards/StorageManagement.html>
/// 
///  Arguments:
///  * `receiver_id`: the valid NEAR account receiving the token
///  * `token_id`: the token to transfer
///  * `approval_id`: expected approval ID. A number smaller than
///     2^53, and therefore representable as JSON. See Approval Management
///     standard for full explanation.
///  * `memo` (optional): for use cases that may benefit from indexing or
///     providing information for a transfer
///  change
nft-transfer: function(receiver-id: account-id, token-id: token-id, approval-id: option<u64>, memo: option<string>)

///  Transfer token and call a method on a receiver contract. A successful
///  workflow will end in a success execution outcome to the callback on the NFT
///  contract at the method `nft_resolve_transfer`.
/// 
///  You can think of this as being similar to attaching native NEAR tokens to a
///  function call. It allows you to attach any Non-Fungible Token in a call to a
///  receiver contract.
/// 
///  Requirements:
///  * Caller of the method must attach a deposit of 1 yoctoⓃ for security
///    purposes
///  * Contract MUST panic if called by someone other than token owner or,
///    if using Approval Management, one of the approved accounts
///  * The receiving contract must implement `ft_on_transfer` according to the
///    standard. If it does not, FT contract's `ft_resolve_transfer` MUST deal
///    with the resulting failed cross-contract call and roll back the transfer.
///  * Contract MUST implement the behavior described in `ft_resolve_transfer`
///  * `approval_id` is for use with Approval Management extension, see
///    that document for full explanation.
///  * If using Approval Management, contract MUST nullify approved accounts on
///    successful transfer.
/// 
///  Arguments:
///  * `receiver_id`: the valid NEAR account receiving the token.
///  * `token_id`: the token to send.
///  * `approval_id`: expected approval ID. A number smaller than
///     2^53, and therefore representable as JSON. See Approval Management
///     standard for full explanation.
///  * `memo` (optional): for use cases that may benefit from indexing or
///     providing information for a transfer.
///  * `msg`: specifies information needed by the receiving contract in
///     order to properly handle the transfer. Can indicate both a function to
///     call and the parameters to pass to that function.
///  change
nft-transfer-call: function(receiver-id: account-id, token-id: token-id, approval-id: option<u64>, memo: option<string>, msg: string)

///  Initializes the contract owned by `owner_id` with
///  default metadata (for example purposes only).
///  change
new-default-meta: function(owner-id: account-id)

///  Returns the token with the given `token_id` or `null` if no such token.
nft-token: function(token-id: token-id) -> option<token>


///  Mint a new token with ID=`token_id` belonging to `token_owner_id`.
/// 
///  Since this example implements metadata, it also requires per-token metadata to be provided
///  in this call. `self.tokens.mint` will also require it to be Some, since
///  `StorageKey::TokenMetadata` was provided at initialization.
/// 
///  `self.tokens.mint` will enforce `predecessor_account_id` to equal the `owner_id` given in
///  initialization call to `new`.
///  change
nft-mint: function(token-id: token-id, token-owner-id: account-id, token-metadata: token-metadata) -> token


///  change
nft-revoke-all: function(token-id: token-id)

///  change
nft-revoke: function(token-id: token-id, account-id: account-id)

nft-metadata: function() -> nft-contract-metadata


nft-is-approved: function(token-id: token-id, approved-account-id: account-id, approval-id: option<u64>) -> bool


nft-tokens-for-owner: function(account-id: account-id, from-index: option<u128>, limit: option<u64>) -> list<token>


nft-supply-for-owner: function(account-id: account-id) -> u128


///  change
new: function(owner-id: account-id, metadata: nft-contract-metadata)

